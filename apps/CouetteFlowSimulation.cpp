//======================================================================================================================
//! \file CouetteFlowSimulation.cpp
//! \author Your Name
//! \brief Couette Flow Simulation with temperature-dependent viscosity using waLBerla and materforge
//======================================================================================================================

#include "blockforest/Initialization.h"
#include "blockforest/communication/UniformBufferedScheme.h"
#include "core/Environment.h"
#include "core/math/Constants.h"
#include "field/AddToStorage.h"
#include "field/communication/PackInfo.h"
#include "stencil/D3Q19.h"
#include "field/vtk/VTKWriter.h"
#include "timeloop/SweepTimeloop.h"
#include "core/timing/TimingPool.h"

// Include generated headers (these should be generated by your Python scripts)
#include "gen/CouetteFlowKernel.hpp"

namespace walberla {
namespace couette_flow {

using namespace walberla;

// Type definitions
typedef GhostLayerField<real_t, 1> ScalarField;
typedef GhostLayerField<Vector3<real_t>, 1> VectorField;
typedef GhostLayerField<real_t, 19> PdfField;

// Material properties structure
struct MaterialProperties {
    real_t density;
    real_t reference_viscosity;
    real_t temperature_coefficient; // α in μ(T) = μ₀ * exp(-α * (T - T_ref))
    real_t reference_temperature;
    real_t thermal_conductivity;
    real_t specific_heat;
    
    MaterialProperties() :
        density(7850.0),
        reference_viscosity(0.001),
        temperature_coefficient(0.002),
        reference_temperature(300.0),
        thermal_conductivity(50.0),
        specific_heat(500.0)
    {}
    
    // Temperature-dependent viscosity: μ(T) = μ₀ * exp(-α * (T - T_ref))
    real_t getDynamicViscosity(real_t temperature) const {
        return reference_viscosity * std::exp(-temperature_coefficient * (temperature - reference_temperature));
    }
    
    // Kinematic viscosity: ν = μ/ρ
    real_t getKinematicViscosity(real_t temperature) const {
        return getDynamicViscosity(temperature) / density;
    }
    
    // Thermal diffusivity: α = k/(ρ*cp)
    real_t getThermalDiffusivity() const {
        return thermal_conductivity / (density * specific_heat);
    }
};

// Boundary condition application
void applyBoundaryConditions(const shared_ptr<StructuredBlockForest>& blocks,
                           BlockDataID velocityId, BlockDataID temperatureId,
                           real_t wallVelocity, real_t hotTemperature, real_t coldTemperature) {
    
    for (auto block = blocks->begin(); block != blocks->end(); ++block) {
        VectorField* velocity = block->getData<VectorField>(velocityId);
        ScalarField* temperature = block->getData<ScalarField>(temperatureId);
        
        // Get domain boundaries
        CellInterval domain = velocity->xyzSizeWithGhostLayer();
        
        // Top wall (moving wall with prescribed velocity and temperature)
        if (blocks->atDomainYMaxBorder(*block)) {
            CellInterval topWall = domain;
            topWall.yMin() = topWall.yMax();
            
            for (auto cell = topWall.begin(); cell != topWall.end(); ++cell) {
                velocity->get(*cell) = Vector3<real_t>(wallVelocity, 0.0, 0.0);
                temperature->get(*cell) = hotTemperature;
            }
        }
        
        // Bottom wall (stationary wall with cold temperature)
        if (blocks->atDomainYMinBorder(*block)) {
            CellInterval bottomWall = domain;
            bottomWall.yMax() = bottomWall.yMin();
            
            for (auto cell = bottomWall.begin(); cell != bottomWall.end(); ++cell) {
                velocity->get(*cell) = Vector3<real_t>(0.0, 0.0, 0.0);
                temperature->get(*cell) = coldTemperature;
            }
        }
        
        // Periodic boundaries in x and z directions (no action needed)
    }
}

// Initialize fields
void initializeFields(const shared_ptr<StructuredBlockForest>& blocks,
                     BlockDataID velocityId, BlockDataID temperatureId, BlockDataID viscosityId,
                     const MaterialProperties& material, 
                     real_t hotTemperature, real_t coldTemperature) {
    
    for (auto block = blocks->begin(); block != blocks->end(); ++block) {
        VectorField* velocity = block->getData<VectorField>(velocityId);
        ScalarField* temperature = block->getData<ScalarField>(temperatureId);
        ScalarField* viscosity = block->getData<ScalarField>(viscosityId);
        
        // Get domain size
        const auto& domain = blocks->getDomain();
        const real_t domainHeight = domain.ySize();
        
        // Initialize with linear temperature and velocity profiles
        for (auto cell = velocity->beginXYZ(); cell != velocity->end(); ++cell) {
            Cell localCell = cell.cell();
            Cell globalCell = localCell;
            blocks->transformBlockLocalToGlobalCell(globalCell, *block);
            
            // Get physical position
            Vector3<real_t> cellCenter = blocks->getCellCenter(globalCell);
            real_t y_normalized = (cellCenter[1] - domain.yMin()) / domainHeight;
            
            // Linear temperature profile
            real_t temp = coldTemperature + (hotTemperature - coldTemperature) * y_normalized;
            temperature->get(localCell) = temp;
            
            // Linear velocity profile (Couette flow)
            real_t u_x = (temp - coldTemperature) / (hotTemperature - coldTemperature); // Normalized by wall velocity
            velocity->get(localCell) = Vector3<real_t>(u_x, 0.0, 0.0);
            
            // Temperature-dependent viscosity
            viscosity->get(localCell) = material.getDynamicViscosity(temp);
        }
    }
}

// Main simulation function
int main(int argc, char** argv) {
    mpi::Environment env(argc, argv);
    
    // Simulation parameters
    const uint_t timesteps = 10000;
    const uint_t vtkWriteFrequency = 100;
    
    // Physical parameters
    const real_t wallVelocity = 1.0;      // m/s - top wall velocity
    const real_t hotTemperature = 800.0;   // K - top wall temperature  
    const real_t coldTemperature = 300.0;  // K - bottom wall temperature
    const real_t channelHeight = 0.01;     // m - channel height
    const real_t dx = 0.0001;              // m - grid spacing
    const real_t dt = 1e-6;                // s - time step
    
    // Domain size
    const uint_t xBlocks = 1, yBlocks = 1, zBlocks = 1;
    const uint_t xCells = 100, yCells = 50, zCells = 10;
    const real_t xSize = xCells * dx;
    const real_t ySize = yCells * dx; 
    const real_t zSize = zCells * dx;
    
    // Material properties
    MaterialProperties material;
    
    WALBERLA_LOG_INFO_ON_ROOT("=== Couette Flow Simulation ===");
    WALBERLA_LOG_INFO_ON_ROOT("Domain: " << xSize << " x " << ySize << " x " << zSize << " m");
    WALBERLA_LOG_INFO_ON_ROOT("Grid: " << xCells << " x " << yCells << " x " << zCells << " cells");
    WALBERLA_LOG_INFO_ON_ROOT("Wall velocity: " << wallVelocity << " m/s");
    WALBERLA_LOG_INFO_ON_ROOT("Temperature range: " << coldTemperature << " - " << hotTemperature << " K");
    
    // Create block forest
    auto aabb = math::AABB(0, 0, 0, xSize, ySize, zSize);
    shared_ptr<StructuredBlockForest> blocks = blockforest::createUniformBlockGrid(
        aabb, xBlocks, yBlocks, zBlocks, xCells, yCells, zCells, 
        true, true, false, false // periodic in x,y; not in z
    );
    
    // Add fields
    BlockDataID pdfFieldId = field::addToStorage<PdfField>(blocks, "pdfs", real_t(0.0), field::fzyx, 1);
    BlockDataID velocityId = field::addToStorage<VectorField>(blocks, "velocity", Vector3<real_t>(0,0,0), field::fzyx, 1);
    BlockDataID temperatureId = field::addToStorage<ScalarField>(blocks, "temperature", real_t(300.0), field::fzyx, 1);
    BlockDataID viscosityId = field::addToStorage<ScalarField>(blocks, "viscosity", material.reference_viscosity, field::fzyx, 1);
    BlockDataID densityId = field::addToStorage<ScalarField>(blocks, "density", material.density, field::fzyx, 1);
    BlockDataID forceId = field::addToStorage<VectorField>(blocks, "force", Vector3<real_t>(0,0,0), field::fzyx, 1);
    
    // Initialize fields
    initializeFields(blocks, velocityId, temperatureId, viscosityId, material, 
                    hotTemperature, coldTemperature);
    
    // Communication schemes
    blockforest::communication::UniformBufferedScheme<stencil::D3Q19> commVector(blocks);
    commVector.addPackInfo(make_shared<field::communication::PackInfo<VectorField>>(velocityId));
    
    blockforest::communication::UniformBufferedScheme<stencil::D3Q19> commScalar(blocks);
    commScalar.addPackInfo(make_shared<field::communication::PackInfo<ScalarField>>(temperatureId));
    commScalar.addPackInfo(make_shared<field::communication::PackInfo<ScalarField>>(viscosityId));
    
    // Create a simple LBM sweep (placeholder - you would use generated code here)
    auto lbmSweep = [&](IBlock* block) {
        // This is where your generated LBM kernel would go
        // For now, this is a placeholder that updates temperature-dependent viscosity
        
        ScalarField* temperature = block->getData<ScalarField>(temperatureId);
        ScalarField* viscosity = block->getData<ScalarField>(viscosityId);
        
        for (auto cell = temperature->beginXYZ(); cell != temperature->end(); ++cell) {
            real_t temp = temperature->get(cell.cell());
            viscosity->get(cell.cell()) = material.getDynamicViscosity(temp);
        }
    };
    
    // Time loop
    SweepTimeloop timeloop(blocks, timesteps);
    
    // Add sweeps to timeloop
    timeloop.add() 
        << Sweep(lbmSweep, "LBM Sweep")
        << AfterFunction([&]() {
            commVector();
            commScalar();
            applyBoundaryConditions(blocks, velocityId, temperatureId, 
                                  wallVelocity, hotTemperature, coldTemperature);
        }, "Communication and BCs");
    
    // VTK output
    if (vtkWriteFrequency > 0) {
        auto vtkOutput = vtk::createVTKOutput_BlockData(*blocks, "CouetteFlow", vtkWriteFrequency, 0, 
                                                      false, "vtk_out", "simulation_step", false, true, true, false, 0);
        
        auto velocityWriter = make_shared<field::VTKWriter<VectorField>>(velocityId, "velocity");
        auto temperatureWriter = make_shared<field::VTKWriter<ScalarField>>(temperatureId, "temperature");
        auto viscosityWriter = make_shared<field::VTKWriter<ScalarField>>(viscosityId, "viscosity");
        
        vtkOutput->addCellDataWriter(velocityWriter);
        vtkOutput->addCellDataWriter(temperatureWriter);
        vtkOutput->addCellDataWriter(viscosityWriter);
        
        timeloop.addFuncAfterTimeStep(vtk::writeFiles(vtkOutput), "VTK Output");
    }
    
    // Run simulation
    WcTimingPool timeloopTiming;
    WcTimer simTimer;
    
    WALBERLA_LOG_INFO_ON_ROOT("Starting simulation...");
    simTimer.start();
    timeloop.run(timeloopTiming);
    simTimer.end();
    
    // Performance results
    real_t simTime = real_c(simTimer.max());
    WALBERLA_MPI_SECTION() { 
        walberla::mpi::reduceInplace(simTime, walberla::mpi::MAX); 
    }
    
    const auto reducedTimeloopTiming = timeloopTiming.getReduced();
    
    WALBERLA_LOG_RESULT_ON_ROOT("=== Simulation completed ===");
    WALBERLA_LOG_RESULT_ON_ROOT("Total simulation time: " << simTime << " seconds");
    WALBERLA_LOG_RESULT_ON_ROOT("Time per timestep: " << (simTime / timesteps * 1000) << " ms");
    WALBERLA_LOG_RESULT_ON_ROOT("Performance timing:\n" << *reducedTimeloopTiming);
    
    return EXIT_SUCCESS;
}

} // namespace couette_flow
} // namespace walberla

int main(int argc, char** argv) { 
    return walberla::couette_flow::main(argc, argv); 
}
