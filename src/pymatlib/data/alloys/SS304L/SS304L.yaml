# The general convention in this file are SI units m, s, kg, A, V, K, etc.

# ====================================================================================================

# To create an alloy, the following inputs are always required:
# name: alloy_name

# composition:
#   element_1: composition fraction
#   element_2: composition fraction
#   element_3: composition fraction

# solidus_temperature: 1605  # the highest temperature at which an alloy is solid – where melting begins

# liquidus_temperature: 1735  # temperature at which an alloy is completely melted

# ====================================================================================================

# Any material property can be set in four ways:

# 1. constant float properties
# eg: density: 7950  # kg/m³


# 2. file based properties (input via a .txt, .csv or .xlsx file)
# 2.1. Simple format
# property_name: path/to/file
# eg: density: ./density_temperature.txt
# eg: density: ./density_temperature.csv
# eg: density: ./density_temperature.xlsx
# Note: this 'simple format' assigns the first column of the input file to the temperature data (K)
#       and the second column to the corresponding property data.

# 2.2 Advanced format
# property_name:
#   file: ./path/to/file
#   temp_col: Temperature  # Name of the temperature column
#   prop_col: Property  # Name of the property column
# Note: Advanced format is required when you have a file with multiple columns.
# Note: For .txt files, columns should be space/tab separated


# 3. key-val pair properties
# property_name:
#   key: list of temperature values or tuple with start and increment/decrement value
#   val: property values
# eg: density:
#       key: [solidus_temperature, liquidus_temperature]   # References to defined temperatures
#       val: [7262.34, 7037.47]  # Corresponding density values (kg/m³)
# eg: density:
#       key: [1735.00, 1730.00, 1720.00, 1715.00, 1710.00, 1700.00, 1695.00, 1690.00]  # Explicit temperature list (K)
#       val: [7037.470, 7060.150, 7110.460, 7127.680, 7141.620, 7172.590, 7184.010, 7192.780]  # Corresponding values
# eg: density:
#       key: (1735.00, -5)  # Start at 1735.00K and decrement by 5K for each value in val
#       # [1735.00, 1730.00, 1725.00, 1720.00, 1715.00, 1710.00, 1705.00, 1700.00, 1695.00, 1690.00]
#       val: [7037.470, 7060.150, 7088.800, 7110.460, 7127.680, 7141.620, 7156.800, 7172.590, 7184.010, 7192.780]
# Note: When using a tuple for key, the generated temperature points will be:
#       [start, start+increment, start+2*increment, ...] until matching the length of val


# 4. computed properties
# 4.1. Simple format (currently supported for density, thermal_diffusivity, energy_density only)
# property_name: compute
# eg: density: compute
# eg: thermal_diffusivity: compute
# eg: energy_density: compute
# Note: simple format uses the default model to compute the property
# Note: the equations used here are:
# - Density by thermal expansion: rho(T) = rho_0 / (1 + tec * (T - T_0))^3
# Required properties: base_temperature, base_density, thermal_expansion_coefficient
# - Thermal diffusivity by heat conductivity: alpha(T) = k(T) / (rho(T) * c_p(T))
# Required properties: heat_conductivity, density, heat_capacity
# - Energy density (standard model): rho(T) * (c_p(T) * T + L)
# Required properties: density, heat_capacity, latent_heat_of_fusion

# 4.2. Advanced format (currently supported for energy_density only)
# property_name:
#   compute: model_name
# eg: energy_density:
#       compute: enthalpy_based
# eg: energy_density:
#       compute: total_enthalpy
# Note: the equations used here are:
# - Energy density (enthalpy_based model): rho(T) * (h(T) + L)
# Required properties: density, specific_enthalpy, latent_heat_of_fusion
# - Energy density (total_enthalpy model): rho(T) * h(T)
# Required properties: density, specific_enthalpy

# Note: If energy_density is a compute method, an additional property 'energy_density_temperature_array' needs to be specified
# energy_density_temperature_array: (start, stop, third_parameter)

# The third_parameter can be interpreted in two ways:
# - If it's a float value (e.g., 5.0 or -5.0), it's treated as the temperature increment/decrement between points
# eg: energy_density_temperature_array: (300, 3000, 5.0) # From 300K to 3000K in steps of 5K
# eg: energy_density_temperature_array: (3000, 300, -5.0) # From 3000K to 300K in steps of -5K

# - If it's an integer value (e.g., 541), it's treated as the total number of points to generate
# eg: energy_density_temperature_array: (300, 3000, 541) # 541 evenly spaced points from 300K to 3000K
# eg: energy_density_temperature_array: (3000, 300, 541) # 541 evenly spaced points from 3000K to 300K

# ====================================================================================================

# Important Notes:
#   1. If a specific property is defined in multiple ways or multiple times, the parser will throw an error.
#   2. If required dependencies for computed properties are missing, an error will be raised.
#   3. Properties will be computed in the correct order regardless of their position in the file.
#   4. All numerical values must use period (.) as decimal separator, not comma.
#   5. Interpolation between data points is performed automatically for file-based and key-val properties.
#   6. To retrieve temperature from energy_density, use the default "interpolate" method from within
#   the generated class from InterpolationArrayContainer named after the alloy.

# ====================================================================================================


name: SS304L

composition:
  Fe: 0.675
  Cr: 0.170
  Ni: 0.120
  Mo: 0.025
  Mn: 0.010


solidus_temperature: 1605
liquidus_temperature: 1735


properties:
  # energy_density:
  # key: (500, 20)
  # val: [...]
  #OR
  # energy_density: compute
  #OR
  energy_density:
    compute: total_enthalpy  # Explicit model selection
  # User can specify either:
  energy_density_temperature_array: (300, 3000, 541)  # int for number of points
  # OR
  #energy_density_temperature_array: (300, 3000, 5.0)   # float for delta (increment)
  # save the energy_density and temperature as arrays always.


  #density: 7950.
  #OR
  #density: compute  # computed by thermal expansion coefficient, should be acceptable even if TEC is defined later in the file
  base_temperature: 2273.
  base_density: 6.591878918e3
  #OR
  density:
    file: ./304L_Erstarrungsdaten_edited.xlsx
    temp_col: T (K)
    prop_col: Density (kg/(m)^3)


  heat_conductivity:
    file: ./304L_Erstarrungsdaten_edited.xlsx
    temp_col: T (K)
    prop_col: Thermal conductivity (W/(m*K))-TOTAL-10000.0(K/s)


  heat_capacity:
    file: ./304L_Erstarrungsdaten_edited.xlsx
    temp_col: T (K)
    prop_col: Specific heat (J/(Kg K))

  thermal_expansion_coefficient: 16.3e-6

  specific_enthalpy:
    file: ./304L_Erstarrungsdaten_edited.xlsx
    temp_col: T (K)
    prop_col: Enthalpy (J/kg)

  latent_heat_of_fusion:
    file: ./304L_Erstarrungsdaten_edited.xlsx
    temp_col: T (K)
    prop_col: Latent heat (J/Kg)
  #OR
  # latent_heat_of_fusion:
    # key: [solidus_temperature, liquidus_temperature]
    # val: [171401, 0]


  # heat_conductivity:
    # key: [1200, 1800, 2200, 2400]  # temperature values
    # val: [25, 30, 33, 35]  # corresponding heat_conductivity values


  # heat_capacity:
    # key: [solidus_temperature, liquidus_temperature]
    # val: [600, 800]
  #OR
  # heat_capacity:
    # key: (1000, 200)  # generates equidistant values starting 1000 with an increment of 200 until the length of val
    # [1000, 1200, 1400, 1600, 1800, 2000, 2200, 2400, 2600, 2800, 3000, 3200]
    # val: [580, 590, 600, 600, 600, 610, 620, 630, 660, 700, 750, 750]
  #OR
  # heat_capacity:
    # key: [1000, 1200, 1400, 1600, ...]
    # val: [580, 590, 600, 600, 600, 610, 620, 630, 660, 700, 750, 780, 789, 799, 800, 800, 800, ...]
  #OR
  # heat_capacity: file.txt  # file with 2 columns of data


  thermal_diffusivity: compute  # use implemented function: heat_conductivity / (density * heat_capacity)


  # electrical_conductivity: compute  # use implemented function: heat_conductivity / (LorenzNumber * temperature)


  # heat_capacity: compute  # check dependency circles -> here throw an error!!!
